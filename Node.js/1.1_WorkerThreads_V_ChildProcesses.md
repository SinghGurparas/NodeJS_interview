# Worker Threads VS Child Processes

The main difference between **worker threads** and **child processes** in Node.js comes down to **memory space, startup cost, and communication**.

Here’s the breakdown:

---

## **1. Memory & Execution Environment**

* **Worker Threads**

  * Share the **same process** as the parent.
  * Have **separate V8 contexts** (isolated JS heaps), but can share memory via `SharedArrayBuffer`.
  * Lower memory overhead compared to child processes.

* **Child Processes**

  * Run in a **completely separate process** with its own memory space, event loop, and V8 instance.
  * No memory sharing (all communication is via IPC).

---

## **2. Communication**

* **Worker Threads**

  * Use `parentPort.postMessage()` and `SharedArrayBuffer` for fast communication.
  * Data is transferred using **structured clone** (fast, no JSON serialization needed).

* **Child Processes**

  * Communicate via **IPC** (Inter-Process Communication) using `.send()` and `process.on('message')`.
  * Usually involves serialization/deserialization (slower).

---

## **3. Startup Cost**

* **Worker Threads** → Lighter & faster startup, since they don’t spawn a new OS process.
* **Child Processes** → Heavier & slower startup, because they require forking the Node.js process.

---

## **4. Use Cases**

* **Worker Threads**

  * CPU-intensive work (e.g., image processing, crypto hashing, large JSON parsing).
  * Cases where you need shared memory between tasks.
* **Child Processes**

  * Running separate Node.js applications.
  * Isolating crashes or resource limits.
  * Calling non-JS executables or scripts.
  * Avoiding memory leaks spilling over.

---

## **5. Summary Table**

| Feature             | Worker Threads                     | Child Processes                 |
| ------------------- | ---------------------------------- | ------------------------------- |
| Process isolation   | ❌ No (same process)                | ✅ Yes (separate process)        |
| Memory sharing      | ✅ Possible via `SharedArrayBuffer` | ❌ No                            |
| Startup cost        | Low                                | High                            |
| Communication speed | Fast                               | Slower (IPC serialization)      |
| Crash isolation     | ❌ No                               | ✅ Yes                           |
| Ideal for           | CPU-heavy JS                       | Separate apps, external scripts |

---

💡 **One-liner mental model:**

> Worker Threads = *lightweight parallelism inside the same Node.js process*.
> Child Processes = *fully separate Node.js instances with stronger isolation but higher cost*.

---

If you want, I can give you a **visual diagram** showing where the memory & event loops are in each model — makes the difference really obvious.





---

## **1️⃣ High-Level Difference**

| Feature             | Worker Threads                                                                    | Child Processes                                                              |
| ------------------- | --------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| **Process**         | Runs inside **same Node.js process** as parent.                                   | Runs in a **separate Node.js process**.                                      |
| **Memory Space**    | Separate V8 heap, but can share memory via `SharedArrayBuffer`.                   | Completely isolated memory — no direct sharing.                              |
| **Communication**   | `postMessage()` / `parentPort.on(...)` (structured clone) or `SharedArrayBuffer`. | IPC via `.send()` and `process.on('message')` (serialized data).             |
| **Startup Cost**    | Light — no OS process spawn.                                                      | Heavier — forks full Node.js runtime.                                        |
| **Crash Isolation** | ❌ Crash affects the whole process.                                                | ✅ Crash only affects that child process.                                     |
| **Ideal For**       | CPU-bound tasks, heavy computation, memory sharing.                               | Running separate apps, integrating with other executables, strong isolation. |
| **Limitations**     | No built-in crash protection, no automatic variable sharing.                      | No memory sharing, slower communication.                                     |

---

## **2️⃣ Resource Sharing**

| Resource                   | Worker Threads                                                              | Child Processes                                             |
| -------------------------- | --------------------------------------------------------------------------- | ----------------------------------------------------------- |
| **Variables / Objects**    | ❌ Not automatic, must pass explicitly.                                      | ❌ Not automatic, must pass explicitly.                      |
| **Memory Buffers**         | ✅ Yes, via `SharedArrayBuffer` + typed arrays (instant access, no copying). | ❌ No — always copied via IPC.                               |
| **Database Connections**   | ❌ Not shareable (must create per thread).                                   | ❌ Not shareable (must create per process).                  |
| **Environment Variables**  | ✅ Inherited at creation; later changes are not auto-synced.                 | ✅ Inherited at creation; later changes are not auto-synced. |
| **File Descriptors (FDs)** | ✅ Possible to pass via message channels.                                    | ✅ Possible to pass via IPC.                                 |

---

## **3️⃣ Example Usage**

### **Worker Threads**

**Use Case:** CPU-heavy image processing with shared memory for pixel data.

```js
// main.js
const { Worker } = require('worker_threads');

const buffer = new SharedArrayBuffer(1024 * 1024); // 1MB shared buffer
const worker = new Worker('./worker.js', { workerData: buffer });

worker.on('message', msg => console.log('Worker done:', msg));
```

```js
// worker.js
const { workerData, parentPort } = require('worker_threads');
const data = new Uint8Array(workerData);

// modify shared data
for (let i = 0; i < data.length; i++) data[i] = 255;

parentPort.postMessage('Pixels processed');
```

**Benefits:**

* No copying of the large buffer.
* Changes visible instantly in both threads.

---

### **Child Processes**

**Use Case:** Run a separate Node.js script for web scraping, isolated from main app.

```js
// main.js
const { fork } = require('child_process');

const scraper = fork('./scraper.js');
scraper.send({ url: 'https://example.com' });

scraper.on('message', data => console.log('Scraped data:', data));
```

```js
// scraper.js
process.on('message', async ({ url }) => {
  const html = `<html> ... scraped content ... </html>`;
  process.send({ html });
  process.exit();
});
```


Node.js provides **four main ways** to create child processes, all from the [`child_process`](https://nodejs.org/api/child_process.html) module.
They differ in **how they spawn the process, how data is passed, and whether a shell is involved**.

---

## **1️⃣ `spawn()`**

* **Purpose:** Launches a new process with a given command.
* **Returns:** A `ChildProcess` object with streaming interfaces for `stdin`, `stdout`, `stderr`.
* **Use case:** Long-running processes, continuous output streaming.
* **Example:**

```js
const { spawn } = require('child_process');

const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', data => console.log(`Output: ${data}`));
ls.stderr.on('data', data => console.error(`Error: ${data}`));
ls.on('close', code => console.log(`Exited with code ${code}`));
```

* **Notes:** Does not spawn via a shell by default (faster, safer).

---

## **2️⃣ `exec()`**

* **Purpose:** Runs a command in a shell, buffers the whole output, and passes it to a callback.
* **Returns:** A `ChildProcess` object but main data comes via the callback.
* **Use case:** Short-lived commands with small output.
* **Example:**

```js
const { exec } = require('child_process');

exec('ls -lh /usr', (error, stdout, stderr) => {
  if (error) {
    console.error(`Error: ${error.message}`);
    return;
  }
  console.log(`Output:\n${stdout}`);
});
```

* **Notes:** Output is buffered in memory — not good for huge output.

---

## **3️⃣ `execFile()`**

* **Purpose:** Similar to `exec()`, but directly executes a binary file **without using a shell**.
* **Returns:** A `ChildProcess` object, output via callback.
* **Use case:** Running executables or scripts directly for better performance and security.
* **Example:**

```js
const { execFile } = require('child_process');

execFile('node', ['-v'], (error, stdout, stderr) => {
  if (error) throw error;
  console.log(`Node version: ${stdout}`);
});
```

* **Notes:** Avoids shell parsing vulnerabilities (e.g., shell injection).

---

## **4️⃣ `fork()`**

* **Purpose:** Special case of `spawn()` for running **Node.js modules** with IPC (message passing).
* **Returns:** A `ChildProcess` object with `.send()` and `process.on('message')` for communication.
* **Use case:** Creating multiple Node.js processes that communicate with the parent.
* **Example:**

```js
// parent.js
const { fork } = require('child_process');
const child = fork('./child.js');

child.on('message', msg => console.log('From child:', msg));
child.send({ hello: 'world' });

// child.js
process.on('message', msg => {
  console.log('From parent:', msg);
  process.send({ foo: 'bar' });
});
```

* **Notes:** Great for worker-like patterns in pure Node.js without external binaries.

---

## **Summary Table**

| Method       | Uses Shell? | Streaming?   | IPC Support | Best For                                 |
| ------------ | ----------- | ------------ | ----------- | ---------------------------------------- |
| **spawn**    | ❌ No        | ✅ Yes        | ❌ No        | Long-running commands, continuous output |
| **exec**     | ✅ Yes       | ❌ (buffers)  | ❌ No        | Short commands, small output             |
| **execFile** | ❌ No        | ❌ (buffers)  | ❌ No        | Executing binaries/scripts securely      |
| **fork**     | ❌ No        | ❌ (messages) | ✅ Yes       | Running Node.js modules with IPC         |

---

If you want, I can also **add a diagram showing how each type connects the parent and child process**
so you can instantly recall which ones use streaming, which use a shell, and which support IPC in interviews.


**Benefits:**

* If scraper crashes or leaks memory, main process is unaffected.
* Can run totally different logic or even other languages.

---

## **4️⃣ Quick Decision Guide**

* **Need shared memory, faster comms, low startup cost?** → ✅ Worker Threads
* **Need strong crash isolation, running different apps/scripts, or external binaries?** → ✅ Child Processes
* **Need DB connections or stateful services shared?** → ❌ Neither (create per worker/process)



