# ASYNCHRONOUS PROGRAMMING

## **1. Async Programming in Node.js**

**Q:** What is asynchronous programming in Node.js and why is it important?
**A:**

* **Definition:** Async programming allows tasks to run without blocking the main thread. Node.js uses an **event loop** to handle multiple operations concurrently.
* **Importance:** Since Node.js is **single-threaded**, blocking code can freeze the entire app. Async patterns (callbacks, promises, async/await) let Node handle many I/O operations efficiently.

**Example:**

```js
console.log("Start");
setTimeout(() => console.log("Async task done"), 1000);
console.log("End");

// Output:
// Start
// End
// Async task done
```

---

## **2. Callbacks**

**Q:** What is a callback in Node.js?

**A:**

* A **callback** is a function passed as an argument to another function, to be executed later (often after an async task finishes).
* Common in Node's core APIs, especially older ones.

**Example:**

```js
function fetchData(callback) {
    setTimeout(() => {
        callback(null, "Data received");
    }, 1000);
}

fetchData((err, data) => {
    if (err) return console.error(err);
    console.log(data);
});
```

⚠ **Drawback:** Can lead to "callback hell" — nested callbacks that are hard to read and maintain.

### **Callback Hell — Example & Explanation**

**What is Callback Hell?**
It happens when multiple async operations depend on each other and are written with nested callbacks, creating deeply indented, hard-to-read code.

**Example (BAD):**

```js
getUser(1, function(err, user) {
    if (err) return console.error(err);
    getOrders(user.id, function(err, orders) {
        if (err) return console.error(err);
        getOrderDetails(orders[0].id, function(err, details) {
            if (err) return console.error(err);
            console.log(details);
        });
    });
});
```

* **Why it’s bad:**

  * **Readability** suffers (deep indentation).
  * **Error handling** is repetitive.
  * Hard to **modify** or **debug**.

---

**Improved (Using Promises):**

```js
getUser(1)
    .then(user => getOrders(user.id))
    .then(orders => getOrderDetails(orders[0].id))
    .then(details => console.log(details))
    .catch(err => console.error(err));
```

**Improved (Using Async/Await):**

```js
async function main() {
    try {
        const user = await getUser(1);
        const orders = await getOrders(user.id);
        const details = await getOrderDetails(orders[0].id);
        console.log(details);
    } catch (err) {
        console.error(err);
    }
}
main();
```

✅ **Better:** Flat structure, central error handling, more readable.

---

## **3. Promises**

**Q:** How do promises work in Node.js?

**A:**

* A **Promise** is an object that represents the eventual completion or failure of an async operation.
* Has 3 states: *pending*, *fulfilled*, *rejected*.
* Methods: `.then()` for success, `.catch()` for errors, `.finally()` for cleanup.

**Example:**

```js
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => resolve("Data received"), 1000); // or reject("Error ocurred!")
    });
}

fetchData()
    .then(data => console.log(data)) // when promise gets resolved
    .catch(err => console.error(err)) // when promise gets rejected
    .finally(data=>console.log("final :- ", data)); //runs for either resolved or rejected
```

---

## **4. Error Handling**

### **Using try-catch (with async/await)**

```js
async function getData() {
    try {
        let data = await fetchData();
        console.log(data);
    } catch (err) {
        console.error("Error:", err);
    }
}
getData();
```

### **Using callbacks**

```js
fetchData((err, data) => {
    if (err) {
        console.error("Error:", err);
        return;
    }
    console.log(data);
});
```

### **Using promises & `.catch()`**

```js
fetchData()
    .then(data => console.log(data))
    .catch(err => console.error("Error:", err));
```

---

## **5. Exception Handling in Node.js**

**Q:** How does Node.js handle exceptions?

**A:**

* **Synchronous errors** → caught using `try-catch`.
* **Asynchronous errors** → handled inside callbacks, `.catch()` for promises, or `try-catch` inside `async` functions.
* **Process-level handling:**

```js
process.on('uncaughtException', err => {
    console.error("Uncaught Exception:", err);
});
process.on('unhandledRejection', err => {
    console.error("Unhandled Promise Rejection:", err);
});
```

⚠ These should be used for **logging and graceful shutdown**, not for normal flow control.

---

### **Interviewer-style follow-up questions:**

1. **Why can’t try-catch handle async errors in callbacks?**
   → Because `try-catch` only works in the same call stack. Async callbacks run in a future tick of the event loop, outside the current call stack.

    **Key point:**
        *`try-catch` only works within the **same synchronous execution context** (call stack).
        * Async callbacks run later, after the current function has already finished.

    **Example where try-catch fails:**

    ```js
        try {
            setTimeout(() => {
                throw new Error("Async error!");
            }, 1000);
        } catch (err) {
            console.error("Caught error:", err); // ❌ Won’t catch
        }
    ```

    **Why?**

    * When `setTimeout` schedules the callback, the current call stack ends.
    * The error happens in a **future tick** of the event loop, outside the scope of the `try-catch`.

    ---

    **Correct way to handle it:**

    * For callbacks: pass the error as the **first argument** and handle it inside the callback.

    ```js
        function doAsyncTask(callback) {
            setTimeout(() => {
                callback(new Error("Something went wrong"), null);
            }, 1000);
        }

        doAsyncTask((err, result) => {
            if (err) {
                console.error("Handled error:", err.message);
                return;
            }
            console.log(result);
        });
    ```

    * For Promises: use `.catch()`
    * For Async/Await: wrap with `try-catch`

2. **What’s the difference between a promise rejection and throwing an error?**
   → Throwing an error is synchronous; rejecting a promise is asynchronous. In `async` functions, `throw` automatically becomes a rejected promise.

---