# Databases (Mongo and SQL)

## INDEX

- [Databases (Mongo and SQL)](#databases-mongo-and-sql)
  - [INDEX](#index)
  - [Normalization in MYSQL](#normalization-in-mysql)
    - [First Normal Form (1NF)](#first-normal-form-1nf)
    - [Second Normal Form (2NF)](#second-normal-form-2nf)
    - [Third Normal Form (3NF)](#third-normal-form-3nf)
  - [Transactions and ACID Properties](#transactions-and-acid-properties)
    - [**Transactions:**](#transactions)
    - [**ACID Properties:**](#acid-properties)

## Normalization in MYSQL

Normalization: "Normalization is the process of organizing your database to reduce data redundancy and improve data integrity. You break down large tables into smaller, related tables and use relationships (like foreign keys) between them. The goal is that each piece of data is stored only once.

- **Benefits:**

    Prevents update anomalies (where you might update one record but forget another), and generally keeps data accurate.

- **When to use :**

    Good for transactional systems (e.g., e-commerce orders, banking) where data accuracy and consistency are paramount, and write operations are frequent.

### First Normal Form (1NF)

**Rule:** A table is in 1NF if it meets two conditions:

1. All columns contain atomic values (each cell holds only one piece of data, not a list).
2. Each row is unique.

**Example:** We split the repeating group of courses into separate rows.

**Table: `student_courses_1nf`**

| StudentID | StudentName | CourseID | CourseName | Professor | Grade |
|---|---|---|---|---|---|
| 1 | Alice | 101 | Intro to DB | Dr. Smith | A |
| 1 | Alice | 102 | Data Structures | Dr. Jones | B |
| 2 | Bob | 101 | Intro to DB | Dr. Smith | C |
| 2 | Bob | 103 | Algorithms | Dr. White | A |

(Note: This table is already in 1NF from our UNF example because the data was structured this way. The key is that there are no "lists" or "arrays" within a single cell.)

---

### Second Normal Form (2NF)

**Rule:** A table is in 2NF if it meets these conditions:

1. It is in 1NF.
2. All non-key attributes (columns that are not part of the primary key) are fully dependent on the entire primary key. This applies only to tables with a composite primary key (a primary key made of two or more columns).

**Example:**

- **Primary Key:** `(StudentID, CourseID)`
- `StudentName` depends only on `StudentID`, not on `CourseID`. This is a **partial dependency**.
- `CourseName` and `Professor` depend only on `CourseID`. This is also a **partial dependency**.

**Solution:** We break the table into three separate tables to eliminate these partial dependencies.

1. **`students` Table:**

    | StudentID | StudentName |
    |---|---|
    | 1 | Alice |
    | 2 | Bob |

2. **`courses` Table:**

    | CourseID | CourseName | Professor |
    |---|---|---|
    | 101 | Intro to DB | Dr. Smith |
    | 102 | Data Structures | Dr. Jones |
    | 103 | Algorithms | Dr. White |

3. **`enrollments` Table:** (The linking table with the composite primary key)

    | StudentID | CourseID | Grade |
    |---|---|---|
    | 1 | 101 | A |
    | 1 | 102 | B |
    | 2 | 101 | C |
    | 2 | 103 | A |

---

### Third Normal Form (3NF)

**Rule:** A table is in 3NF if it meets these conditions:

1. It is in 2NF.
2. There are no transitive dependencies. A transitive dependency occurs when a non-key attribute is dependent on another non-key attribute.

**Example:** Let's look at the `courses` table from 2NF:

**`courses` Table**

| CourseID | CourseName | Professor |
|---|---|---|
| 101 | Intro to DB | Dr. Smith |
| 102 | Data Structures | Dr. Jones |
| 103 | Algorithms | Dr. White |

- **Primary Key:** `CourseID`
- **Non-key attributes:** `CourseName`, `Professor`
- `Professor` is not dependent on `CourseID` but is dependent on `CourseName`. For example, "Intro to DB" is always taught by "Dr. Smith". This is a **transitive dependency**.
- (Okay, that's not a great example. A better one would be if we had a `ProfessorID` and `Professor` in the table. The `Professor` name would depend on the `ProfessorID` which in turn depends on the `CourseID`.)

**Let's use a better example:** Imagine the `courses` table also had a `ProfessorOffice` column.
`courses` Table:

| CourseID | CourseName | Professor | ProfessorOffice |
|---|---|---|---|
| 101 | Intro to DB | Dr. Smith | A101 |
| 102 | Data Structures | Dr. Jones | A102 |

- `ProfessorOffice` depends on `Professor` (a non-key attribute), which in turn depends on `CourseID`. This is a **transitive dependency**.

**Solution:** We move the `ProfessorOffice` to a new `professors` table.

1. **`courses` Table (modified):**

    | CourseID | CourseName | ProfessorID |
    |---|---|---|
    | 101 | Intro to DB | 1 |
    | 102 | Data Structures | 2 |

2. **`professors` Table:**

    | ProfessorID | ProfessorName | ProfessorOffice |
    |---|---|---|
    | 1 | Dr. Smith | A101 |
    | 2 | Dr. Jones | A102 |

This eliminates the transitive dependency and puts the database in 3NF. Most databases are designed up to 3NF, as it provides a good balance between data integrity and performance.

## Transactions and ACID Properties

### **Transactions:**

   A transaction is a single logical unit of work performed on a database. It's a sequence of one or more SQL statements (like INSERT, UPDATE, DELETE) that are treated as a single, indivisible operation. Either all the statements within a transaction succeed and are committed to the database, or if any part fails, the entire transaction is rolled back, leaving the database unchanged.

### **ACID Properties:**

ACID is an acronym that describes the key properties guaranteeing data integrity in a transactional database. They are crucial for reliability:

- **Atomicity:**

    (All or Nothing) - This means a transaction is treated as a single, indivisible unit. Either all the operations within it complete successfully, or none of them do. If any part fails, the entire transaction is rolled back. Example: Transferring money from account A to account B. You deduct from A and add to B. If adding to B fails, the deduction from A is also undone.

- **Consistency:**

    (Valid State) - A transaction brings the database from one valid state to another valid state. It ensures that data rules (like unique constraints, foreign key relationships) are always maintained. Example: If you try to insert a record that violates a unique constraint, the transaction will be rolled back, preventing the database from entering an invalid state.

- **Isolation:**

    (Independent Execution) - Transactions execute independently of each other. Changes made by one transaction are not visible to other concurrent transactions until the first transaction is committed. This prevents weird results from concurrent operations. Example: If two users try to update the same product's stock simultaneously, isolation ensures that their updates don't interfere with each other and the final stock count is correct.

- **Durability:**

    (Permanent Changes) - Once a transaction is committed, its changes are permanent and will survive system failures (like power outages). The committed data is written to persistent storage. Example: After a customer successfully places an order and the transaction is committed, even if the server crashes right after, the order data will still be in the database when it restarts."

Importance for Node.js: "For Node.js applications, especially those dealing with critical data like financial transactions, inventory management, or user data, ACID properties are vital. They ensure that even with multiple users or concurrent operations, your data remains accurate, consistent, and reliable, preventing data corruption and business logic errors.
