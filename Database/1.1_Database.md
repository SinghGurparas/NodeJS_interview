# Databases (Mongo and SQL)

## INDEX

- [Databases (Mongo and SQL)](#databases-mongo-and-sql)
  - [INDEX](#index)
  - [Normalization in MYSQL](#normalization-in-mysql)
    - [First Normal Form (1NF)](#first-normal-form-1nf)
    - [Second Normal Form (2NF)](#second-normal-form-2nf)
    - [Third Normal Form (3NF)](#third-normal-form-3nf)

## Normalization in MYSQL

Normalization: "Normalization is the process of organizing your database to reduce data redundancy and improve data integrity. You break down large tables into smaller, related tables and use relationships (like foreign keys) between them. The goal is that each piece of data is stored only once.

- **Benefits:**

    Prevents update anomalies (where you might update one record but forget another), and generally keeps data accurate.

- **When to use :**

    Good for transactional systems (e.g., e-commerce orders, banking) where data accuracy and consistency are paramount, and write operations are frequent.

### First Normal Form (1NF)

**Rule:** A table is in 1NF if it meets two conditions:

1. All columns contain atomic values (each cell holds only one piece of data, not a list).
2. Each row is unique.

**Example:** We split the repeating group of courses into separate rows.

**Table: `student_courses_1nf`**

| StudentID | StudentName | CourseID | CourseName | Professor | Grade |
|---|---|---|---|---|---|
| 1 | Alice | 101 | Intro to DB | Dr. Smith | A |
| 1 | Alice | 102 | Data Structures | Dr. Jones | B |
| 2 | Bob | 101 | Intro to DB | Dr. Smith | C |
| 2 | Bob | 103 | Algorithms | Dr. White | A |

(Note: This table is already in 1NF from our UNF example because the data was structured this way. The key is that there are no "lists" or "arrays" within a single cell.)

---

### Second Normal Form (2NF)

**Rule:** A table is in 2NF if it meets these conditions:

1. It is in 1NF.
2. All non-key attributes (columns that are not part of the primary key) are fully dependent on the entire primary key. This applies only to tables with a composite primary key (a primary key made of two or more columns).

**Example:**

- **Primary Key:** `(StudentID, CourseID)`
- `StudentName` depends only on `StudentID`, not on `CourseID`. This is a **partial dependency**.
- `CourseName` and `Professor` depend only on `CourseID`. This is also a **partial dependency**.

**Solution:** We break the table into three separate tables to eliminate these partial dependencies.

1. **`students` Table:**

    | StudentID | StudentName |
    |---|---|
    | 1 | Alice |
    | 2 | Bob |

2. **`courses` Table:**

    | CourseID | CourseName | Professor |
    |---|---|---|
    | 101 | Intro to DB | Dr. Smith |
    | 102 | Data Structures | Dr. Jones |
    | 103 | Algorithms | Dr. White |

3. **`enrollments` Table:** (The linking table with the composite primary key)

    | StudentID | CourseID | Grade |
    |---|---|---|
    | 1 | 101 | A |
    | 1 | 102 | B |
    | 2 | 101 | C |
    | 2 | 103 | A |

---

### Third Normal Form (3NF)

**Rule:** A table is in 3NF if it meets these conditions:

1. It is in 2NF.
2. There are no transitive dependencies. A transitive dependency occurs when a non-key attribute is dependent on another non-key attribute.

**Example:** Let's look at the `courses` table from 2NF:

**`courses` Table**

| CourseID | CourseName | Professor |
|---|---|---|
| 101 | Intro to DB | Dr. Smith |
| 102 | Data Structures | Dr. Jones |
| 103 | Algorithms | Dr. White |

- **Primary Key:** `CourseID`
- **Non-key attributes:** `CourseName`, `Professor`
- `Professor` is not dependent on `CourseID` but is dependent on `CourseName`. For example, "Intro to DB" is always taught by "Dr. Smith". This is a **transitive dependency**.
- (Okay, that's not a great example. A better one would be if we had a `ProfessorID` and `Professor` in the table. The `Professor` name would depend on the `ProfessorID` which in turn depends on the `CourseID`.)

**Let's use a better example:** Imagine the `courses` table also had a `ProfessorOffice` column.
`courses` Table:

| CourseID | CourseName | Professor | ProfessorOffice |
|---|---|---|---|
| 101 | Intro to DB | Dr. Smith | A101 |
| 102 | Data Structures | Dr. Jones | A102 |

- `ProfessorOffice` depends on `Professor` (a non-key attribute), which in turn depends on `CourseID`. This is a **transitive dependency**.

**Solution:** We move the `ProfessorOffice` to a new `professors` table.

1. **`courses` Table (modified):**

    | CourseID | CourseName | ProfessorID |
    |---|---|---|
    | 101 | Intro to DB | 1 |
    | 102 | Data Structures | 2 |

2. **`professors` Table:**

    | ProfessorID | ProfessorName | ProfessorOffice |
    |---|---|---|
    | 1 | Dr. Smith | A101 |
    | 2 | Dr. Jones | A102 |

This eliminates the transitive dependency and puts the database in 3NF. Most databases are designed up to 3NF, as it provides a good balance between data integrity and performance.
